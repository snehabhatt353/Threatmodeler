{
  "id": "24",
  "name": "Input Validation",
  "description": "<div>Input validation is performed to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.</div><div><br /></div><div>Data from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.</div><div><br /></div><div>\n</div><div>\n</div><div>Input Validation should not be used as the primary method of preventing XSS, SQL Injection and other attacks which are covered in respective cheat sheets but can significantly contribute to reducing their impact if implemented properly.</div><div><br /></div><div>\n</div><div>\n</div><div><b>Input validation strategies\n</b></div><div>Input validation should be applied on both syntactical and Semantic level.\n</div><div><br /></div><ul><li>Syntactic validation should enforce correct syntax of structured fields (e.g. SSN, date, currency symbol). <br /></li><li>Semantic validation should enforce correctness of their values in the specific business context (e.g. start date is before end date, price is within expected range).\n</li></ul><div>\nIt is always recommended to prevent attacks as early as possible in the processing of the user's (attacker's) request. Input validation can be used to detect unauthorized input before it is processed by the application.</div><div><br /></div><div><b>Implementing input validation\n</b></div><div>Input validation can be implemented using any programming technique that allows effective enforcement of syntactic and semantic correctness, for example:\n</div><div><br /></div><ul><li>Data type validators available natively in web application frameworks (such as Django Validators, Apache Commons Validators etc).\n</li><li>Validation against JSON Schema and XML Schema (XSD) for input in these formats.\n</li><li>Type conversion (e.g. Integer.parseInt() in Java, int() in Python) with strict exception handling\n</li><li>Minimum and maximum value range check for numerical parameters and dates, minimum and maximum length check for strings.\n</li><li>Array of allowed values for small sets of string parameters (e.g. days of week).\n</li><li>Regular expressions for any other structured data covering the whole input string (^...$) and not using &quot;any character&quot; wildcard (such as . or \\S)</li></ul><div><br /></div><div>\n</div><div><b>Use whitelisting over blacklisting\n</b></div><div>It is a common mistake to use black list validation in order to try to detect possibly dangerous characters and patterns like the apostrophe ' character, the string 1=1, or the &lt;script&gt; tag, but this is a massively flawed approach as it is trivial for an attacker to bypass such filters.\n</div><div><br /></div><div>Plus, such filters frequently prevent authorized input, like O'Brian, where the ' character is fully legitimate. \n</div><div><br /></div><div>White list validation is appropriate for all input fields provided by the user. White list validation involves defining exactly what IS authorized, and by definition, everything else is not authorized.\n</div><div><br /></div><div>If it's well structured data, like dates, social security numbers, zip codes, email addresses, etc. then the developer should be able to define a very strong validation pattern, usually based on regular expressions, for validating such input.\n</div><div><br /></div><div>If the input field comes from a fixed set of options, like a drop down list or radio buttons, then the input needs to match exactly one of the values offered to the user in the first place.\n</div><div><b><br /></b></div><div><b>Validating free-form Unicode text\n:</b></div><div>Free-form text, especially with Unicode characters, is perceived as difficult to validate due to a relatively large space of characters that need to be whitelisted.\n</div><div><br /></div><div>It's also free-form text input that highlights the importance of proper context-aware output encoding and quite clearly demonstrates that input validation is not the primary safeguards against Cross-Site Scripting. If your users want to type apostrophe ' or less-than sign &lt; in their comment field, they might have perfectly legitimate reason for that and the application's job is to properly handle it throughout the whole life cycle of the data.\n</div><div><br /></div><div><b>The primary means of input validation for free-form text input should be:\n</b></div><div><br /></div><ul><li>Normalization: Ensure canonical encoding is used across all the text and no invalid characters are present.\n</li><li>Character category whitelisting: Unicode allows whitelisting categories such as &quot;decimal digits&quot; or &quot;letters&quot; which not only covers the Latin alphabet but also various other scripts used globally (e.g. Arabic, Cyrillic, CJK ideographs etc).\n</li><li>Individual character whitelisting: If you allow letters and ideographs in names and also want to allow apostrophe ' for Irish names, but don't want to allow the whole punctuation category.\n</li></ul><div><b>White List Regular Expression Examples:</b></div><div>Validating a U.S. Zip Code (5 digits plus optional -4)\n</div><div>^\\d{5}(-\\d{4})?$\n</div><div><br /></div><div>Validating U.S. State Selection From a Drop-Down Menu\n</div><div>^(AA|AE|AP|AL|AK|AS|AZ|AR|CA|CO|CT|DE|DC|FM|FL|GA|GU|HI|ID|IL|IN|IA|KS|KY|LA|ME|MH|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|MP|OH|OK|OR|PW|PA|PR|RI|SC|SD|TN|TX|UT|VT|VI|VA|WA|WV|WI|WY)$\n</div><div><br /></div><div><b>Java Regex Usage Example:\n</b></div><div>Example validating the parameter &quot;zip&quot; using a regular expression.\n</div><div><br /></div><div>private static final Pattern zipPattern = Pattern.compile(&quot;^\\d{5}(-\\d{4})?$&quot;); <br /></div><div>\n</div><div>public void doPost( HttpServletRequest request, HttpServletResponse response) {\n</div><div>  try {\n</div><div>      String zipCode = request.getParameter( &quot;zip&quot; );\n</div><div>      if ( !zipPattern.matcher( zipCode ).matches()  {\n</div><div>          throw new YourValidationException( &quot;Improper zipcode format.&quot; );\n</div><div>      }\n</div><div>      // do what you want here, after its been validated ..\n</div><div>  } catch(YourValidationException e ) {\n</div><div>      response.sendError( response.SC_BAD_REQUEST, e.getMessage() );\n</div><div>  }\n</div><div>}\n</div><div><br /></div><div><b>Client Side vs Server Side Validation\n:</b></div><div>Be aware that any JavaScript input validation performed on the client can be bypassed by an attacker that disables JavaScript or uses a Web Proxy. Ensure that any input validation performed on the client is also performed on the server.\n</div><div>\n</div><div><b><br /></b></div><div><b>Resource:</b></div><div><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html\" target=\"_blank\">https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html</a></div><div><br /></div>",
  "labels": "ThreatModeler,AppSec and InfraSec,ACH Transfer,Transfer Fund,Wire Transfer,Login,Registration,Forgot Password,Change Password,Forms,TM-566,Web Application,Web Service,Profile,Create,Delete,CRUD,Update,Read,Third Party Web Service",
  "libraryId": "1",
  "isHidden": false,
  "guid": "e3e7ec28-3b3c-42bd-8e47-f370529240c6",
  "riskId": 4,
  "isCompensatingControl": false,
  "riskName": "Low",
  "isReadOnlyLibraryEntity": false,
  "lastUpdated": "2021-12-15T15:56:38.147",
  "libraryGuid": "eef7dcf9-53bd-48e9-849d-21445ebad101"
}