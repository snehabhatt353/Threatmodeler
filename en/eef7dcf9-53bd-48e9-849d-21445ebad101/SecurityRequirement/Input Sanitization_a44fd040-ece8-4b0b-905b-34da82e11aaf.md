{
  "id": "91",
  "name": "Input Sanitization",
  "description": "<p>Do not program input values directly on command shell, instead treat user input as guilty until proven innocent. Build a function that takes user input and converts it to applications specific types and values, stripping or filtering out all unauthorized commands and characters in the process.</p><p>Three of the top five most common website attacks – SQL injection, cross-site scripting (XSS), and remote file inclusion (RFI) – share a root cause in common: input sanitization. Or to be more accurate, a lack thereof.</p><p>All three exploits are leveraged by data sent to the Web server by the end user. When the end user is a good guy, the data he sends the server is relevant to his interaction with the website. But when the end user is a hacker, she can exploit this mechanism to send the Web server input which is deliberately constructed to escape the legitimate context and execute unauthorized actions.</p><p>Input sanitization describes cleansing and scrubbing user input to prevent it from jumping the fence and exploiting security holes. But thorough input sanitization is hard. While some vulnerable sites simply don’t sanitize at all, others do so incompletely, lending their owners a false sense of security.</p><p>Incoming Data Dangers</p><p>There are three roads data can take to get from a user’s browser to the Web server:</p><p>GET requests. These are parameters included in the URL, often (but not always) generated by form input on a Web page. The parameters in a GET request appear after the question mark in a URL:</p><p>http://company.com/contact.php?firstname=joe&amp;lastname=sixpackAnyone can easily manipulate the data in a GET request simply by editing the URL.</p><p>POST requests. These are parameters included in the header information sent from the browser to the Web server. POST data does not appear in the URL, but can be manipulated by hackers using browser plugins like Tamper Data For Firefox  or simply with custom code using a library like cURL.</p><p>Cookies. Often overlooked when sanitizing input, cookies created by a website can contain exploitable data. Cookies are stored as plain text files on the end user’s machine and can easily be modified by a hacker to manipulate input data sent to the server.</p><p>Where user input is echoed back to the Web page – requires that data be sanitized before output. Because we are defending against Web page injection, you need to escape HTML special characters including tag brackets (&lt; &gt;) and the entity ampersand (&amp;) so they are not rendered by the browser.<br /></p><p>PHP developers can use the function filter_input to do the heavy lifting:</p><p>$safe_data=filter_input(INPUT_GET, 'comment', FILTER_SANITIZE_SPECIAL_CHARS);</p><p>Because this function only works on a single GET parameter at a time, you might want to write a function to make a new array (e.g. $SAFE_GET) which iterates through the GET parameters and sanitizes them all in one go.</p><p>Alternatively you can set a directive in the php.ini file to default to sanitizing all input for HTML safety:</p><p>filter.default=&quot;special_chars&quot;</p><p>Enclose all attributes in quotes! Although simply stated, this defense speaks to the need for discipline and consistency in Web development as its own defense against input sanitization exploits. Where there are holes, rodents will sneak in.</p><p>You must escape all user input before including it in an SQL query. In PHP this is done using the function mysql_real_escape_string(). Never include any data in an SQL query without passing it through this function first!</p><p>The best defense against SQL injection attacks is not related to input sanitization at all. Although this goes beyond the scope of this article, ideally your Web application should not construct SQL queries using user input at all. Rather, it should rely on prepared statements and parameter binding.</p><p><br /></p><p>Reference:</p><p><a target=\"_blank\" href=\"https://www.esecurityplanet.com/browser-security/prevent-web-attacks-using-input-sanitization.html\">https://www.esecurityplanet.com/browser-security/prevent-web-attacks-using-input-sanitization.html</a></p>",
  "labels": "ThreatModeler,AppSec and InfraSec,ACH Transfer,Transfer Fund,Wire Transfer,Login,Registration,Forgot Password,Change Password,Forms,Web Application,TM-420,Web Service,Profile,Delete,CRUD,Create,Update,Read,Third Party Web Service",
  "libraryId": "1",
  "isHidden": false,
  "guid": "a44fd040-ece8-4b0b-905b-34da82e11aaf",
  "riskId": 4,
  "isCompensatingControl": false,
  "riskName": "Low",
  "isReadOnlyLibraryEntity": false,
  "lastUpdated": "2021-12-15T15:56:38.413",
  "libraryGuid": "eef7dcf9-53bd-48e9-849d-21445ebad101"
}