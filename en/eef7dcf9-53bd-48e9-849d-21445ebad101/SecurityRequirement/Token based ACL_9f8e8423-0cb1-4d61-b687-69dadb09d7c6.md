{
  "id": "155",
  "name": "Token based ACL",
  "description": "Associate some ACL (in the form of a token) with an authenticated user which they provide middleware. The middleware uses this token as part of its channel/message selection for that client, or part of a discerning authorization decision for privileged channels/messages. [Source?]\r\nIn addition to resolving the CSRF issues in your application, you also need to resolve the XSS issues in your application. If those still exist, the CSRF defenses can be circumvented.\r\n\r\nTo protect the app against a CSRF attack, consider the following use of the OWASP ESAPI:\r\nStep 1. Generate new CSRF token and add it to user once on login and store user in http session.\r\nThis code should be executed when the user logs into the application. This is done in the default ESAPI implementation, and it is stored as a member variable of the User object that gets stored in the session.\r\n//this code is in the DefaultUser implementation of ESAPI\r\n\r\n/** This user's CSRF token. */\r\n\r\nprivate String csrfToken = resetCSRFToken();\r\n\r\n...\r\npublic String resetCSRFToken() {\r\n\r\ncsrfToken = ESAPI.randomizer().getRandomString(8, DefaultEncoder.CHAR_ALPHANUMERICS);\r\n\r\nreturn csrfToken;\r\n\r\n}\r\n\r\nStep 2. On any forms or urls that should be protected, add the token as a parameter / hidden field.\r\nThe addCSRFToken method below should be called for any url that is going to be rendered that needs CSRF protection. Alternatively if you are creating a form, or have another technique of rendering URLs (like c:url), then be sure to add a parameter or hidden field with the name \"ctoken\" and the value of DefaultHTTPUtilities.getCSRFToken(). That should do the work of adding the data to the url or form. We'll validate it in the next step.\r\n//from HTTPUtilitiles interface\r\nfinal static String CSRF_TOKEN_NAME = \"ctoken\";\r\n\r\n//this code is from the DefaultHTTPUtilities implementation in ESAPI\r\n\r\npublic String addCSRFToken(String href) {\r\n\r\nUser user = ESAPI.authenticator().getCurrentUser();\r\n\r\nif (user.isAnonymous()) {\r\n\r\nreturn href;\r\n\r\n}\r\n\r\n// if there are already parameters append with &, otherwise append with ?\r\n\r\nString token = CSRF_TOKEN_NAME + \"=\" + user.getCSRFToken();\r\n\r\nreturn href.indexOf( '?') != -1 ? href + \"&\" + token : href + \"?\" + token;\r\n\r\n}\r\n\r\n...\r\n\r\npublic String getCSRFToken() {\r\n\r\nUser user = ESAPI.authenticator().getCurrentUser();\r\n\r\nif (user == null) return null;\r\n\r\nreturn user.getCSRFToken();\r\n\r\n}\r\n\r\n\r\nStep 3. On the server side for those protected actions, check that the submitted token matches the token from the user object in the session. (Assuming you've implemented this properly, a failure constitutes a security issue.)\r\nEnsure that you call this method from your servlet or struts action or jsf controller, or whatever server side mechanism you're using to handle requests. This should be called on any request that you need to validate for CSRF protection. Notice that when the tokens do not match, it's considered a possible forged request.\r\n\r\n//this code is from the DefaultHTTPUtilities implementation in ESAPI\r\n\r\npublic void verifyCSRFToken(HttpServletRequest request) throws IntrusionException {\r\n\r\nUser user = ESAPI.authenticator().getCurrentUser();\r\n\r\n// check if user authenticated with this request - no CSRF protection required\r\n\r\nif( request.getAttribute(user.getCSRFToken()) != null ) {\r\n\r\nreturn;\r\n\r\n}\r\n\r\nString token = request.getParameter(CSRF_TOKEN_NAME);\r\n\r\nif ( !user.getCSRFToken().equals( token ) ) {\r\n\r\nthrow new IntrusionException(\"Authentication failed\", \"Possibly forged HTTP request without proper CSRF token detected\");\r\n\r\n}\r\n\r\n}\r\n\r\n\r\nStep 4. On logout and session timeout, the user object is removed from the session and the session destroyed.\r\nIn this step, logout is called. When that happens, note that the session is invalidated and the current user object is reset to be an anonymous user, thereby removing the reference to the current user and accordingly the csrf token.\r\n//this code is in the DefaultUser implementation of ESAPI\r\n\r\npublic void logout() {\r\n\r\nESAPI.httpUtilities().killCookie( ESAPI.currentRequest(), ESAPI.currentResponse(), HTTPUtilities.REMEMBER_TOKEN_COOKIE_NAME );\r\n\r\nHttpSession session = ESAPI.currentRequest().getSession(false);\r\n\r\nif (session != null) {\r\n\r\nremoveSession(session);\r\n\r\nsession.invalidate();\r\n\r\n}\r\n\r\nESAPI.httpUtilities().killCookie(ESAPI.currentRequest(), ESAPI.currentResponse(), \"JSESSIONID\");\r\n\r\nloggedIn = false;\r\n\r\nlogger.info(Logger.SECURITY_SUCCESS, \"Logout successful\" );\r\n\r\nESAPI.authenticator().setCurrentUser(User.ANONYMOUS);\r\n\r\n}",
  "labels": "ThreatModeler,AppSec and InfraSec,Firewall,Gateway,Web Application,Native Application,Web Service,App,TM-406",
  "libraryId": "1",
  "isHidden": false,
  "guid": "9f8e8423-0cb1-4d61-b687-69dadb09d7c6",
  "riskId": 2,
  "isCompensatingControl": false,
  "riskName": "High",
  "isReadOnlyLibraryEntity": false,
  "lastUpdated": "2020-09-22T13:26:49.78",
  "libraryGuid": "eef7dcf9-53bd-48e9-849d-21445ebad101"
}