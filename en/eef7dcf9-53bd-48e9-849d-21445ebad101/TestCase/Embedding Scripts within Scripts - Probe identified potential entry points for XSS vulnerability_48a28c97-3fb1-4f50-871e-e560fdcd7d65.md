{
  "id": "136",
  "name": "Embedding Scripts within Scripts - Probe identified potential entry points for XSS vulnerability",
  "description": "The attacker uses the entry points gathered in the \"Explore\" phase as a target list and injects various common script payloads to determine if an entry point actually represents a vulnerability and to characterize the extent to which the vulnerability can be exploited.\nAttack Step Techniques\nID\tAttack Step Technique Description\tEnvironments\n1\t\nManually inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a client-side script elements context and observe system behavior to determine if script was executed.\nenv-Web\n2\t\nManually inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a server-side script elements context and observe system behavior to determine if script was executed.\nenv-Web\n3\t\nUse an automated injection attack tool to inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a client-side script elements context and observe system behavior to determine if script was executed.\nenv-Web\n4\t\nUse an automated injection attack tool to inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a server-side script elements context and observe system behavior to determine if script was executed.\nenv-Web\n5\t\nUse a proxy tool to record results of the created requests.\nenv-Web\nIndicators\nID\tType\tIndicator Description\tEnvironments\n1\tPositive\t\nUser-controllable input is output back to the browser\nenv-Web\n2\tPositive\t\nUser-controllable input is embedded as part of script elements\nenv-Web\n3\tPositive\t\nOutput to the browser is not encoded to remove executable scripting syntax\nenv-Web\n4\tPositive\t\nServer-side components execute script elements containing user-controllable input\nenv-Web\nOutcomes\nID\tType\tOutcome Description\n1\tSuccess\t\nThe attacker's script string is being reflected verbatim at some point in the web site (if not on the same page). Note that sometimes, the payload might be well encoded in the page, but wouldn't be encoded at all in some other section of the same web page (title, etc.)\n2\tSuccess\t\nThe attacker's script string is executed by the server-side component.\n3\tFailure\t\nAll context-sensitive characters are consistently re-encoded before being sent to the web browser.\n4\tInconclusive\t\nSome sensitive characters are consistently encoded, but others are not. Depending on which type of non-script element the payload is injected in, it may be possible to evade the encodings.\nSecurity Controls\nID\tType\tSecurity Control Description\n1\tDetective\t\nMonitor input to web servers (not only GET, but all potential inputs like COOKIES, POST, HEADER), application servers, and other HTTP infrastructure (e.g., load balancers). Alert on standard XSS probes. The majority of attackers use well-known strings to check for vulnerabilities. Use the same vulnerability catalogs that adversaries use.\n2\tPreventative\t\nApply appropriate input validation to filter all user-controllable input of scripting syntax\n3\tPreventative\t\nDo not embed user-controllable input in script elements.\n4\tPreventative\t\nActively monitor the application and either deny or redirect requests from origins that appear to be generating XSS probes.\n\nReference: https://capec.mitre.org/data/definitions/19.html",
  "labels": "CAPEC",
  "libraryId": "1",
  "guid": "48a28c97-3fb1-4f50-871e-e560fdcd7d65",
  "isHidden": false,
  "isReadOnlyLibraryEntity": false,
  "libraryGuid": "eef7dcf9-53bd-48e9-849d-21445ebad101"
}