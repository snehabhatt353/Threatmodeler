{
  "id": "43",
  "name": "Authentication - Credentials Transported over an Encrypted Channel",
  "description": "Sending data with POST method through HTTP \n\nSuppose that the login page presents a form with fields User, Pass, and the Submit button to authenticate and give access to the application. If we look at the header of our request with an interception proxy, we get something like this:\n\nPOST http://www.example.com/AuthenticationServlet HTTP/1.1\nHost: www.example.com\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404\nAccept: text/xml,application/xml,application/xhtml+xml\nAccept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nKeep-Alive: 300\nConnection: keep-alive\nReferer: http://www.example.com/index.jsp\nCookie: JSESSIONID=LVrRRQQXgwyWpW7QMnS49vtW1yBdqn98CGlkP4jTvVCGdyPkmn3S!\nContent-Type: application/x-www-form-urlencoded\nContent-length: 64\n\ndelegated_service=218&User=test&Pass=test&Submit=SUBMIT\n\n\nFrom this example the tester can understand that the POST sends the data to the page www.example.com/AuthenticationServlet simply using HTTP. So, in this case, data are transmitted without encryption and a malicious user could read our username and password by simply sniffing the net with a tool like Wireshark. \n\n\n\nSending data with POST method through HTTPS\n\nSuppose that our web application uses the HTTPS protocol to encrypt data we are sending (or at least for those relating to the authentication). In this case, trying to access the login page and to authenticate, the header of our POST request would be similar to the following: \n\nPOST https://www.example.com:443/cgi-bin/login.cgi HTTP/1.1\nHost: www.example.com\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404\nAccept: text/xml,application/xml,application/xhtml+xml,text/html\nAccept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nKeep-Alive: 300\nConnection: keep-alive\nReferer: https://www.example.com/cgi-bin/login.cgi\nCookie: language=English; \nContent-Type: application/x-www-form-urlencoded\nContent-length: 50\n\nCommand=Login&User=test&Pass=test\n\nWe can see that the request is addressed to www.example.com:443/cgi-bin/login.cgi using the HTTPS protocol. This ensures that our data are sent through an encrypted channel and that they are not readable by other people.\n\n\n\nSending data with POST method via HTTPS on a page reachable via HTTP:\n\nNow, suppose to have a web page reachable via HTTP and that then only data sent from the authentication form are shipped via HTTPS. This means that our data is transmitted in a secure way through encryption. This situation occurs, for example, when we are on a portal of a big company that offers various information and services publicly available, without identification, but which has also a private section accessible from the home page through a login. So when we try to login, the header of our request will look like the following example: \n\nPOST https://www.example.com:443/login.do HTTP/1.1\nHost: www.example.com\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404\nAccept: text/xml,application/xml,application/xhtml+xml,text/html\nAccept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nKeep-Alive: 300\nConnection: keep-alive\nReferer: http://www.example.com/homepage.do\nCookie: SERVTIMSESSIONID=s2JyLkvDJ9ZhX3yr5BJ3DFLkdphH0QNSJ3VQB6pLhjkW6F\nContent-Type: application/x-www-form-urlencoded\nContent-length: 45\n\nUser=test&Pass=test&portal=ExamplePortal\n\n\nWe can see that our request is addressed to www.example.com:443/login.do using HTTPS. But if we have a look at the referer field in the header (the page from which we came), it is www.example.com/homepage.do and is accessible via simple HTTP. So, in this case, we have no lock inside our browser window that tells us that we are using a secure connection, but, in reality, we are sending data via HTTPS. This ensures us that no other people can read the data that we are sending. \n\n\nSending data with GET method through HTTPS:\n\nIn this last example, suppose that the application transfers data using the GET method. This method should never be used in a form that transmits sensitive data such as username and password, because they are displayed in clear in the URL and this entails a whole set of security issues. So this example is purely demonstrative, but, in reality, it is strongly suggested to use the POST method instead. This is because when the GET method is used, the URL that it requests is easily available from, for example, the server logs exposing your sensitive data to information leakage. \n\nGET https://www.example.com/success.html?user=test&pass=test HTTP/1.1\nHost: www.example.com\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.14) Gecko/20080404\nAccept: text/xml,application/xml,application/xhtml+xml,text/html\nAccept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nKeep-Alive: 300\nConnection: keep-alive\nReferer: https://www.example.com/form.html\nIf-Modified-Since: Mon, 30 Jun 2008 07:55:11 GMT\nIf-None-Match: \"43a01-5b-4868915f\"\n\nYou can see that the data is transferred in clear text in the URL and not in the body of the message as before. But we must consider that TLS/SSL is a level 5 protocol, a lower level than HTTP, so the whole HTTP package is still encrypted and the URL is unreadable to an attacker. It is not a good practice to use the GET method in these cases, because the information contained in the URL can be stored in many servers such as proxy and web servers, leaking the privacy of the user's credentials. ",
  "labels": "",
  "libraryId": "1",
  "guid": "7de2b679-6e07-482a-8169-340358f05030",
  "isHidden": false,
  "isReadOnlyLibraryEntity": false,
  "libraryGuid": "eef7dcf9-53bd-48e9-849d-21445ebad101"
}